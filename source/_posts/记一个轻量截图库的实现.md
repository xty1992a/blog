---
title: 记一个轻量截图库的实现
abbrlink: 71b2
date: 2019-10-31 20:51:42
tags:
- canvas
- 浏览器
- JavaScript
- 轮子
categories:
- [技术, 浏览器]
---

> 引子
最近...
算了不编了，我，手痒，要造轮子！

#### 题外话
我以往用的截图功能都是基于[cropperjs](https://github.com/fengyuanchen/cropperjs)实现。比如曾发布的一款用于截图上传的[组件](https://www.npmjs.com/package/@redbuck/image-uploader)。
因为包含了`cropperjs`和`preact`,体积高达66k。当时就有开发一款轻量级截图库的想法。

#### 需求分析
API没什么好分析的，照着`cropperjs`抄就是了。
技术选型上，`cropperjs`在预览，拖拽时，是基于DOM。前端开发一涉及到DOM，麻烦事就很多。尤其是开发类库，尤其是零依赖的类库---拼字符串真的很恶心。所以这个轮子，将使用纯canvas实现所有功能。

#### 整体结构
既然基于canvas，很多在DOM中理所当然的东西都要自己实现，比如事件绑定，获取元素位置等等。另一方面，拖拽，缩放，限制等又涉及到大量计算，如果混在一起就很痛苦了。适当的切割封装非常有必要。
因此代码主要分为3个类。
1. `Cropper`类，暴露出去的主类，它负责接收解析配置，绑定事件监听，绘制图像。
2. `ImageModel`类，描述图像位置尺寸信息的类，负责更新图像在缩放，移动之后信息。
3. `Limiter`类，限制器，描述了一个矩形，提供一些方法用于计算坐标，位置。

#### 难点分析

##### 缩放
拖拽很容易实现，难点的部分在于缩放。
我们先不考虑太多，可以用[drawImage](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage)实现，它的函数签名是：
`ctx.drawImage(image[, sx, sy, sWidth, sHeight], dx, dy[, dWidth, dHeight]);`
直接上代码
````javascript
ctx.drawImage(img, 0,0,100,100)
// 监听鼠标滚轮，等比放大sWidth, sHeight
ctx.drawImage(img, 0,0,200,200)
````
图片将放大到原来的4倍大小。
但是有个问题--图像的坐标始终保持在左上角。
而符合人直觉缩放是，图像以鼠标落点为原点进行缩放。
要实现这一点，dx,dy就必须动态计算。
假设鼠标落点（position）在50,50的位置，放大到新的尺寸（newSize）200,200,那么新的sx,sy就应该是这样计算的：
先将鼠标落点转换为该点在图片内的坐标origin，计算这个需要用到现在的位置current
`origin.x = position.x - current.x`
`dx=current.x+（origin.x-(origin.x / current.width * newSize.width)）`

上面的公式仔细分析，就是计算图片扩大后，在原点左侧增长的尺寸，将这个尺寸加到当前的坐标上，就是新的坐标。
代入计算一下。
origin.x=50-0=50
`dx=0+(50-(50/100*200))`
dx为-50，dy同理，也为-50，将其填入代码。可以发现是正确的。
```javascript
ctx.drawImage(img, -50,-50,200,200)
```

##### 绘制蒙层
这个被扣掉截图库的蒙层其实不难实现，不过挺有意思的，所以来专门说说。
`cropperjs`的实现非常巧妙。底部是完整的图片，盖着一层蒙层，截图框是一个可以移动的元素，里面装着一样大的图片，移动时，图片向相反的方向移动，超出部分隐藏。
canvas没有元素可用，但canvas的API非常强大。这里介绍两种方式。
1. 基于[clip](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/clip)实现。
2. 基于[globalCompositeOperation](https://www.canvasapi.cn/CanvasRenderingContext2D/globalCompositeOperation)实现。

clip剪切一段路径之后，再次绘制只会作用在这个路径上，我们可以利用这一点。
先绘制图像，再绘制全屏的半透明遮罩，将截图框的轮廓剪切出来，再次绘制图像。
代码
```javascript
ctx.drawImage(img, 0,0,100,100);

ctx.save();
ctx.fillStyle = 'rgba(0,0,0,0.6)';
ctx.fillRect(0,0,WIDTH,HEIGHT);//canvas的尺寸
const {x,y,width, height} = this.window;//截图框
ctx.rect(x, y, width, height);
ctx.clip();
ctx.drawImage(img, 0,0,100,100);
ctx.restore();
```